'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/config/','title':"C++编译器环境配置",'section':"Docs",'content':"C++环境配置(Windows系统) 下载安装MinGW-w64详细步骤（c/c++的编译器gcc的windows版）\nMinGW 的全称是：Minimalist GNU on Windows ，实际上是将gcc（c/c++编译器）移植到了 Windows 平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows 中运行的可执行程序。而且还可以使用一些 Windows 不具备的，Linux平台下的开发工具。\n选择它的原因：\n MinGW-w64 是开源软件，可以免费使用。 MinGW-w64 由一个活跃的开源社区在持续维护，不会过时。 MinGW-w64 支持最新的 C语言 标准。 使用 Windows 的C语言运行库，因此编译出的程序不需要第三方 DLL ，可以直接在 Windows 下运行。 总之就是要在windows运行c/c++按就对了。可以理解为c/c++的编译器gcc的windows版。  I. 安装 MinGW   下载 MinGW 64 位安装包：x86_64-win32-seh\n或者去百度网盘下载 x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z\n 链接： https://pan.baidu.com/s/1rdpGMcRD6ovNzDCUycXu7Q?pwd=zdem 提取码：zdem    解压 x86_64-8.1.0-release-win32-seh-rt_v6-rev0.7z ， 可以在bin文件夹中找到 g++.exe 编译器\n  右键-我的电脑-属性-高级系统设置-环境变量-找到PATH环境变量，将g++.exe所在目录 G:\\bin\\x86_64-8.1.0-release-win32-seh-rt_v6-rev0\\mingw64\\bin 写入 PATH 环境变量\n  测试 g++\n安装完成后，点击“开始”→“所有程序”→“附件”→“命令提示符”以启动 CMD。 在 CMD 窗口中敲入 g++ -v，若出现如下内容，则表示 C++ 环境配置成功。\nMicrosoft Windows [版本 10.0.19045.2486] (c) Microsoft Corporation。保留所有权利。 C:\\Users\\sheng\u0026gt;g++ -v Using built-in specs. COLLECT_GCC=g++ COLLECT_LTO_WRAPPER=G:/bin/x86_64-8.1.0-release-win32-seh-rt_v6-rev0/mingw64/bin/../libexec/gcc/x86_64-w64-mingw32/8.1.0/lto-wrapper.exe Target: x86_64-w64-mingw32 Configured with: ../../../src/gcc-8.1.0/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --with-sysroot=/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64 --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=win32 --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=nocona --with-tune=core2 --with-libiconv --with-system-zlib --with-gmp=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-mpfr=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-mpc=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-isl=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-pkgversion='x86_64-win32-seh-rev0, Built by MinGW-W64 project' --with-bugurl=https://sourceforge.net/projects/mingw-w64 CFLAGS='-O2 -pipe -fno-ident -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include' CXXFLAGS='-O2 -pipe -fno-ident -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include' CPPFLAGS=' -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include' LDFLAGS='-pipe -fno-ident -L/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/lib -L/c/mingw810/prerequisites/x86_64-zlib-static/lib -L/c/mingw810/prerequisites/x86_64-w64-mingw32-static/lib ' Thread model: win32 gcc version 8.1.0 (x86_64-win32-seh-rev0, Built by MinGW-W64 project)   小白用户可以参考以下内容： https://blog.csdn.net/jjxcsdn/article/details/123058745  "});index.add({'id':1,'href':'/docs/edit_cpp/','title':"C++编辑器配置",'section':"Docs",'content':"C++代码编辑器配置 本课程采用 vscode 作为代码（文本）编辑器， GCC 作为C++编译器。\n 注意： windows的CMD、（powershell）终端均理解为一种命令行窗口，我们在命令行窗口中，均可调用 g++ 来编译我们的c++代码。   下载vscode，自行安装。下载地址： https://code.visualstudio.com/ 打开vscode, 在菜单栏中选择 终端(terminal)-新建终端(new) ，在vscode中打开（powershell）终端。说明：vscode把命令行窗口内嵌到了软件中，方便在vscode中调用g++来编译我们的c++代码。 测试是否可以正常调用 g++ （属于GCC中专门编译c++的编译器）。在终端中输入如下代码，查看能否正常编译 ex1_1.cpp，输出如图所示内容即说明vscode配置无误。  //ex1_1.cpp //时间：2023/01/29 //作者：李长圣@东华理工大学 //功能：两个数字相加 // //编译：PS C:\\Users\\sheng\\Desktop\\ex1\u0026gt; g++ .\\ex1_1.cpp //运行：PS C:\\Users\\sheng\\Desktop\\ex1\u0026gt; .\\a.exe //输出：12,28 // #include \u0026lt;iostream\u0026gt; using namespace std; int add(int x,int y=8); int main() { int x=4; cout\u0026lt;\u0026lt;add(x)\u0026lt;\u0026lt;\u0026quot;,\u0026quot;; cout\u0026lt;\u0026lt;add(x,add(add(x,add(x))))\u0026lt;\u0026lt;endl; } int add(int x,int y) { return x+y; } vscode中文设置参考以下内容： https://zhuanlan.zhihu.com/p/383252071  "});index.add({'id':2,'href':'/docs/gcc/','title':"g++编译过程",'section':"Docs",'content':"g++编译过程 生成一个可执行文件。包括两部分：编译阶段，链接阶段。\n 编译阶段包括三个步骤。预处理，编译，汇编 \u0026mdash;-\u0026gt; 生成obj文件； 链接阶段对obj文件的合并，生成exe可执行文件。  g++在对源程序执行编译工作时，需要经过以下四个步骤：(其中 -o 可以理解为将生成的文件重命名的作用）\n  预处理：对源程序中的宏定义、包含头文件等进行处理，生成后缀名为.i的文件（使用）\ng++ -E hello.cpp -o hello.i hello.cpp是需要编译的源文件，-o 选项指定输出的文件名。这里使用-E选项编译生成hello.i 文件\n  转化为汇编文件：使用-S 选项，可以将预处理之后的.i文件转换为目标机器的汇编代码.S文件\ng++ -S hello.i -o hello.s 使用该参数可以将.i 文件编译生成.s 文件，输出文件名同样使用-o 选项指定。\n  汇编文件-\u0026gt;目标文件，即转换为机器代码：使用-c选项\ng++ -c hello.s -o hello.o   链接：将上一步产生的目标文件链接为可执行文件，使用-o参数\n静态链接 ld -e main hello.o -o hello.exe 为入口函数，.o文件为需要链接的obj文件。 这一行命令会弹出很多错误信息，因为你没有给出完整的依赖库，实际链接过程较为复杂，这里不做要求，仅了解g++编译链接过程即可，刚兴趣的同学自行搜索相关资料。\n以上过程是g++工具编译cpp源程序的具体过程，在实际使用时我们可以不用按照流程一步步编译，可以一步到位将源程序编译为可执行文件，只需要使用如下命令：\ng++ hello.cpp -o hello.exe  -o：指定生成可执行文件的名称。使用方法为：g++ -o afile file.cpp file.h … （可执行文件不可与待编译或链接文件同名，否则会生成相应可执行文件且覆盖原编译或链接文件），如果不使用-o选项，则会生成默认可执行文件a.out。 -c：只编译不链接，只生成目标文件。 -g：添加gdb调试选项。    参考：\n https://blog.csdn.net/i_love_kbb/article/details/126196876 https://zhuanlan.zhihu.com/p/504742628 https://blog.csdn.net/weixin_43953700/article/details/124890088   "});index.add({'id':3,'href':'/docs/make/','title':"make入门教程",'section':"Docs",'content':"make入门教程 (采用 mingw32-make.exe) 上一节，我们已经学习了如何用g++编译单个.cpp文件。如果有多个 .cpp 文件我们如何来编译我们的程序呢？ Makefile是一种方便的组织代码编译方式。下面我们来创建自己的makefile，编译并链接多个.cpp ，生成可执行程序。\n一个简单的例子 首先举一个简单的例子，在项目文件夹中有三个文件: main.c ，func.c ，func.h ，分别代表着主程序，函数实现和对应的头文件。\nmain.c\n// main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026quot;func.h\u0026quot; int main() { sayHello(); return 0; } func.h\n// func.h void sayHello(); func.c\n// func.c #include \u0026lt;stdio.h\u0026gt; #include \u0026quot;func.h\u0026quot; void sayHello() { printf(\u0026quot;Hello makefiles!\\n\u0026quot;); } 一般情况下，我们将使用以下命令来编译这个项目：\ng++ -o hello.exe main.c func.c -I.\t# 注意最后的点代表当前目录 这条命令编译了两个.c文件 main.c func.c , 并将可执行文件命名为 hello.exe\n -o 定义生成的可执行文件的名字。 -I.代表gcc将在当前目录（.）寻找包含的头文件.  当只有轻微的改动时适当修改一下这条命令就已经足够了，但当添加更多文件时，这就很麻烦了。\n另外，如果你只改动了其中某一个.c文件，这条命令每次都将重新编译所有文件，对于大项目来说效率很低，所以这才需要makefile.\n1 Makefile hello.exe : main.c func.c g++ -o hello.exe main.c func.c -I. 将这条规则写进一个名为makefile的文件，然后在 vscode 终端中键入 mingw32-make.exe 就可以执行文件中的第一条规则了。其中冒号:后面放置的是规则 hello.exe 所依赖的文件，当这些文件改动时，规则 hello.exe 会被重新执行。这里没有放置头文件，所以即使头文件改变，命令行中键入 mingw32-make.exe ，这条规则也不会被执行。当然，就目前来说，这条规则效率很低。\n需要注意的是，在g++命令前有一个tab制表符，在任何命令前都必须有个tab制表符。\n make 这个软件有很多不同的版本，用来支持各种系统。 mingw32-make.exe 是 make 在 win10 下的一个版本。 mingw32-make.exe 和你之前配置的 g++ 在同一位置，之前配置了 g++ 的环境变量，就不用配置 mingw32-make.exe 的环境变量了   2 Makefile hello.exe : main.o func.o g++ -o hello.exe main.o func.o 这里我们通过把目标文件 main.o 和 func.o 放置在规则依赖列表中，make将链接目标文件 main.o func.o 生成可执行文件 hello.exe 。\n这样的makefile足够应对小型项目，但是像之前提到的：依赖文件中没有包含头文件，所以头文件改变后make将不会重新编译.c文件。为了修补这个问题，我们需要将头文件加入到依赖列表中。如下所示：\nhello.exe : main.o func.o g++ -o hello.exe main.o func.o main.o: main.c func.h g++ -c -o main.o main.c -I. func.o: func.c func.h g++ -c -o func.o func.c -I.  -c 指出仅生成目标文件 .o -o 指出生成的目标文件的名字。  make将先编译并生成目标文件 func.o 和 main.o ,之后， 链接这两个文件生成可执行文件 hello.exe\n3 makefile 完整的例子 工作目录中的文件\n-| |---func.h |---func.c |---main.c |---makefile makefile\nhello.exe : main.o func.o g++ -o hello.exe main.o func.o main.o: main.c func.h g++ -c -o main.o main.c -I. func.o: func.c func.h g++ -c -o func.o func.c -I. .PHONY:clean all #由于win10没有rm命令,可以使用del, 参考百度 clean: del *.exe /q /s del *.o /q /s main.c\n// main.c #include \u0026lt;stdio.h\u0026gt; #include \u0026quot;func.h\u0026quot; int main() { sayHello(); return 0; } func.h\n// func.h void sayHello(); func.c\n// func.c #include \u0026lt;stdio.h\u0026gt; #include \u0026quot;func.h\u0026quot; void sayHello() { printf(\u0026quot;Hello makefiles!\\n\u0026quot;); } 在 vscode 终端中，执行如下命令编译、运行、清理程序\n mingw32-make.exe 编译生成exe ./hello.exe 运行程序 mingw32-make.exe clean 删除可执行程序 exe 和目标文件 .o 。注意到以上的makefile中我们定义了clean规则，所以这里可以执行clean规则。  执行过程如下图：\n参考：https://blog.csdn.net/qq_35754154/article/details/127432564\n如果学习完本实例，仍然没有懂make使用方法，建议自己百度make教程学习。  "});index.add({'id':4,'href':'/docs/2_8/','title':"2.8包含警戒：多次声明",'section':"Docs",'content':"为什么写两次 void myFunc(); ，编译器不提示重复定义？ 答：声明可以进行多次，定义只能进行一次。 声明和定义的区别 你或许对这个问题不屑一顾，但仔细想一想这样一个问题：声明和定义的区别到底在哪里？\n区别一  声明告诉编译器，这个变量或函数已经在程序其他地方存在了，所以我正在把这个信息告诉你，下面我要调用的时候请放行。但请不要为我分配任何内存空间，因为已经这个步骤在变量或函数定义的地方进行分配了。 而定义则很清楚了，就是要求分配内存空间。很多时候，声明和定义是合而为一的。  int a; void func() {} 这里同时声明且定义了一个变量和一个函数。\n区别二 这点或许不是每个人都是很清楚的：声明可以进行多次，定义只能进行一次。\nvoid myfunc(); void myfunc(); void myfunc() {} 可以通过编译，而\nvoid myfunc(); void myfunc() {} void myfunc() {} 则会报错，因为重复定义了。\n声明和定义的分离 对于函数来说，我们已经很清楚如何对其进行声明和定义的分离了，这正是我们在成对的 .h/.cpp 中做的事情，这里补充一句，实际上编译器对所有函数的声明和定义都悄悄在前面补上了 extern，因为 extern 代表了声明的动作，当我们包含一个头文件的时候，告诉编译器，我接下来调用到的函数是在它处进行定义的。 那么变量的声明和定义如何分离呢？因为我们大多数时候都是既声明又定义一个变量的，如\nint num; 这里虽然没有给num赋任何初值，但是在此处已经完成内存分配了。前面说过，extern关键词是用作声明的，因此我们可以这样做\nextern int num; int num = 100; 当然，没有人在现实生活中会这样做，而且这两行只能放在全局域中，但至少说明了将变量的声明与定义分离也是可以做到的 如果我们这样写\nextern int num = 0; 就是同时声明与定义了，这时这里的extern则是冗余，可写可不写\n 参考: https://www.jianshu.com/p/92e81ecc8737   "});index.add({'id':5,'href':'/docs/3_7/','title':"3.7 单一定义规则：auto",'section':"Docs",'content':"C++98 auto 早在C++98标准中就存在了auto关键字，那时的auto用于声明变量为自动变量，自动变量意为拥有自动的生命期，这是多余的，因为就算不使用auto声明，变量依旧拥有自动的生命期：\nint a =10 ; //拥有自动生命期 auto int b = 20 ;//拥有自动生命期 static int c = 30 ;//延长了生命期 C++98中的auto多余且极少使用，C++11已经删除了这一用法，取而代之的是全新的auto：变量的自动类型推断。\nC++11 auto auto可以在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型，类似的关键字还有decltype。举个例子：\nint a = 10; auto au_a = a;//自动类型推断，au_a为int类型 cout \u0026lt;\u0026lt; typeid(au_a).name() \u0026lt;\u0026lt; endl; typeid运算符可以输出变量的类型。程序的运行结果输出了int。 这种用法就类似于C#中的var关键字。auto的自动类型推断发生在编译期，所以使用auto并不会造成程序运行时效率的降低。\n参考：C++ auto关键字\n"});index.add({'id':6,'href':'/docs/7_4/','title':"7.4 private本类可访问",'section':"Docs",'content':"private本类可访问 自行编译理解以下代码\n//test_private.cpp //知识点：private 本类可访问 //编译：g++ my.cpp #include \u0026lt;iostream\u0026gt; class Course { public : int getDifficulty( ) { return difficulty;} private: int periodCount( ); int course; int difficulty; }; class Student{ public: Student(int sc,int st); void study(Course \u0026amp; course); void help(Student\u0026amp; other); void exercise(){} private : int otherFunc(){ return 1;} private: int score; int strength; }; void Student:: study(Course \u0026amp; course){ score += 1; strength -= course.getDifficulty(); otherFunc();//OK //int n = course.periodCount( ); //wrong Course类不可访问private函数 } void Student:: help(Student\u0026amp; other){ other.score += 2; //本类可访问private变量 strength -= 2; other.strength -= 4; other.exercise( ); otherFunc( );//OK other.otherFunc();//OK } int main() { return 0; } C++类中对同类对象private成员访问 私有成员变量的概念，在脑海中的现象是，以private关键字声明，是类的实现部分，不对外公开，不能在对象外部访问对象的私有成员变量．\n　然而，在实现拷贝构造函数和赋值符函数时，在函数里利用对象直接访问了私有成员变量，因而，产生了困惑．下面以具体实例进行说明：\n　疑惑：为什么第26行和第32行代码可以编译通过，而第39行和第40行代码会产生编译错误？\n答： 私有是指在类外不能访问,并没说在对象间不能访问。\nclass CTest { public: CTest(int i); CTest(const CTest\u0026amp; rhs); CTest\u0026amp; operator=(const CTest\u0026amp; rhs); void printCTest(const CTest\u0026amp; rhs); private: int value; }; CTest::CTest(int i):value(i) { cout\u0026lt;\u0026lt;\u0026quot;Contructor of CTest\u0026quot;\u0026lt;\u0026lt;endl; } CTest::CTest(const CTest\u0026amp; rhs):value(rhs.value) { cout\u0026lt;\u0026lt;\u0026quot;Copy contructor of CTest\u0026quot;\u0026lt;\u0026lt;endl; } CTest\u0026amp; CTest::operator=(const CTest\u0026amp; rhs) { cout\u0026lt;\u0026lt;\u0026quot;Assign function of CTest\u0026quot;\u0026lt;\u0026lt;endl; if(this == \u0026amp;rhs) return *this; value = rhs.value; //通过对象访问私有成员变量 return *this; } void CTest::printCTest(const CTest\u0026amp; rhs) { cout\u0026lt;\u0026lt;rhs.value\u0026lt;\u0026lt;endl; //通过对象访问私有成员变量 } int main() { CTest t = 1; CTest tt = 2; // cout\u0026lt;\u0026lt;t.value\u0026lt;\u0026lt;endl; //通过对象访问私有成员变量，编译错误 // cout\u0026lt;\u0026lt;tt.value\u0026lt;\u0026lt;endl; //通过对象访问私有成员变量，编译错误 t.printCTest(tt); } 产生这种疑惑的原因是自己对私有成员变量的理解有误，封装是编译期的概念，是针对类型而非对象的，在类的成员函数中可以访问同类型实例对象的私有成员变量．\n具体的解析如下：从变量value的符号是怎么解析的分析．\n1. 确定符号的查找域\n如第26行代码，当编译器发现value变量时，它会在value变量所属的对象rhs的类域中寻找该符号．\n2. 确定当前域中哪些符号可以访问\n由第1步可知，当前查找的域是类域，而printCTest函数在CTest类体中，所以printCTest可以访问CTest类中的所有变量(包括私有成员变量)，因而value符号在CTest类域中被找到．\n如第39行代码，main函数不在CTest类体中，所以main函数不可以访问CTest类域中的私有成员变量．\n3. 符号已查找到，编译通过\n类成员变量的访问权限是编译器强加的，编译器可以找到value，通过编译，自然就可以访问到value变量的值．\n直觉上，我们会以为第26行代码中value符号的查找域应该是对象rhs对应的作用域，然而C++编译器的实现却是在对象rhs的类域查找value符号．\n  启发：有些直觉是靠不住的，需要深入分析其背后的实现原理，才可以理解透彻．\n  总结：C++的访问修饰符的作用是以类为单位，而不是以对象为单位。\n  通俗的讲，同类的对象间可以“互相访问”对方的数据成员，只不过访问途径不是直接访问.\n回来查了一下String类的实现才明白，封装性是对类外的操作来说的，在类内操作本类的一个对象时，可以通过该对象访问其私有成员，这种设计也是挺合理的，因为类是自己设计的，当然自己也就知道类的内部结构，所以没有必要对自己也进行类的“封装”。另有一种说法是：“同种类之间是友元关系”。\n步骤是：通过一个对象调用其public成员函数，此成员函数可以访问到自己的或者同类其他对象的public/private/protected数据成员和成员函数(类的所有对象共用)，而且还需要指明是哪个对象的数据成员(调用函数的对象自己的成员不用指明，因为有this指针；其他对象的数据成员可以通过引用或指针间接指明)\n参考：C++类中对同类对象private成员访问\n"});index.add({'id':7,'href':'/posts/','title':"作业",'section':"简介",'content':"无 "});})();